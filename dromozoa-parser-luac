#! /usr/bin/env lua

-- Copyright (C) 2017 Tomoyuki Fujimori <moyu@dromozoa.com>
--
-- This file is part of dromozoa-parser.
--
-- dromozoa-parser is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- dromozoa-parser is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with dromozoa-parser.  If not, see <http://www.gnu.org/licenses/>.

local dumper = require "dromozoa.parser.dumper"
local error_message = require "dromozoa.parser.error_message"
local write_html = require "dromozoa.parser.write_html"
local symbol_value = require "dromozoa.parser.symbol_value"
local tree_layout = require "dromozoa.parser.tree_layout"
local lua53_lexer = require "dromozoa.parser.lexers.lua53_lexer"
local lua53_parser = require "dromozoa.parser.parsers.lua53_parser"

local function find(u, key)
  while u do
    local value = u[key]
    if value then
      return value
    end
    u = u.parent
  end
end

local function decl_name(u)
  local scope = find(u, "scope")
  local names = scope.names
  names[#names + 1] = {
    value = symbol_value(u);
    defs = { u.id };
    refs = {};
  }
end

local function ref_name(u, key)
  if not key then
    key = "refs"
  end
  local value = symbol_value(u)
  local scope = find(u, "scope")
  while scope do
    local names = scope.names
    for i = #names, 1, -1 do
      local name = names[i]
      if name.value == value then
        local refs = name[key]
        refs[#refs + 1] = u.id
        return true
      end
    end
    scope = scope.parent
  end
end

local function def_name(u)
  return ref_name(u, "defs")
end

local function decl_label(u)
  local value = symbol_value(u)
  local scope = find(u, "scope")
  local labels = scope.labels
  for i = 1, #labels do
    local label = labels[i]
    if label.value == value then
      return nil, "label already defined"
    end
  end
  labels[#labels + 1] = {
    value = symbol_value(u);
    defs = { u.id };
    refs = {};
  }
  return true
end

local function ref_label(u)
  local value = symbol_value(u)
  local proto = find(u, "proto")
  local scope = find(u, "scope")
  while scope and scope.proto == proto do
    local labels = scope.labels
    for i = #labels, 1, -1 do
      local label = labels[i]
      if label.value == value then
        local refs = label.refs
        refs[#refs + 1] = u.id
        return true
      end
    end
    scope = scope.parent
  end
  return nil, "no visible label"
end

local function ref_constant(type, u, value)
  local proto = find(u, "proto")
  local constants = proto.constants
  local n = #constants
  for i = 1, n do
    local constant = constants[i]
    if constant.type == type and constant.value == value then
      local refs = constant.refs
      refs[#refs + 1] = u.id
      return n
    end
  end
  n = n + 1
  constants[n] = {
    type = type;
    value = value;
    refs = { u.id };
  }
end

local function copy_codes(result, source)
  for i = 1, #source do
    result[#result + 1] = source[i]
  end
  return result
end

local function copy_path(source, result)
  if result == nil then
    result = {}
  end
  for i = 1, #source do
    result[i] = source[i]
  end
  return result
end

local function common_path(path1, path2, result)
  if result == nil then
    result = {}
  end
  for i = 1, #path1 do
    local v = path1[i]
    if v == path2[i] then
      result[i] = v
    else
      break
    end
  end
  return result
end

local function make_refs_html(html, refs)
  for i = 1, #refs do
    local ref = refs[i]
    if i > 1 then
      html[#html + 1] = ","
    end
    html[#html + 1] = { "span"; ["data-ref"] = ref; "#" .. ref }
  end
  return html
end

local source_file, html_file = ...
local source

if source_file then
  local handle = assert(io.open(source_file))
  source = handle:read("*a")
  handle:close()
else
  source = io.read("*a")
end

local lexer = lua53_lexer()
local parser = lua53_parser()

local symbol_names = parser.symbol_names
local symbol_table = parser.symbol_table
local max_terminal_symbol = parser.max_terminal_symbol
local terminal_nodes = assert(lexer(source, file))
local root = assert(parser(terminal_nodes, source, file))

root.path = {}

local discover_nodes = {}
local finish_nodes = {}
local messages = {}

local stack1 = { root }
local stack2 = {}
while true do
  local n1 = #stack1
  local u = stack1[n1]
  if not u then
    break
  end
  local n2 = #stack2
  if u == stack2[n2] then
    stack1[n1] = nil
    stack2[n2] = nil
    finish_nodes[#finish_nodes + 1] = u
  else
    local id = #discover_nodes + 1
    u.id = id
    discover_nodes[id] = u
    local path = copy_path(u.path)
    path[#path + 1] = id
    for i = #u, 1, -1 do
      local v = u[i]
      v.parent = u
      v.path = path
      stack1[#stack1 + 1] = v
    end
    stack2[n2 + 1] = u
  end
end

for i = 1, #discover_nodes do
  local u = discover_nodes[i]
  local s = u[0]

  if s == symbol_table.chunk then
    u.protos = {}
    u.scopes = {}
  end

  if u.proto then
    local protos = find(u, "protos")
    local proto = {
      constants = {};
    }
    protos[#protos + 1] = proto
    u.proto = proto
  end

  if u.scope then
    local scopes = find(u, "scopes")
    local scope = {
      proto = find(u, "proto");
      parent = find(u.parent, "scope");
      names = {};
      labels = {};
    }
    scopes[#scopes + 1] = scope
    u.scope = scope
  end

  if s > max_terminal_symbol then
    u.codes = {}
  end
end

for i = 1, #discover_nodes do
  local u = discover_nodes[i]
  local s = u[0]
  local u1, u2, u3, u4, u5 = u[1], u[2], u[3], u[4], u[5]
  local s = u[0]
  local s1 = u1 and u1[0]
  local s2 = u2 and u2[0]
  local s3 = u3 and u3[0]
  local s4 = u4 and u4[0]
  local s5 = u5 and u5[0]

  if s == symbol_table.label then
    local result, message = decl_label(u1)
    if not result then
      error(error_message(message, source, u1.i, source_file))
    end
  elseif s == symbol_table.var then
    if s1 == symbol_table.Name then
      local result
      if u.def then
        u1.ref = "def"
      else
        u1.ref = "ref"
      end
    end
  elseif s == symbol_table.Name then
    if u.decl then
      decl_name(u)
    else
      local ref = u.ref
      local result
      if ref == "def" then
        result = def_name(u)
      elseif ref == "ref" then
        result = ref_name(u)
      end
      if not result then
        ref_constant("string", u, symbol_value(u))
      end
    end
  elseif s == symbol_table.IntegerConstant then
    ref_constant("integer", u, tonumber(symbol_value(u)))
  elseif s == symbol_table.FloatConstant then
    ref_constant("float", u, tonumber(symbol_value(u)))
  elseif s == symbol_table.LiteralString then
    ref_constant("string", u, symbol_value(u))
  end
end

for i = 1, #discover_nodes do
  local u = discover_nodes[i]
  local s = u[0]
  local u1, u2, u3, u4 = u[1], u[2], u[3], u[4]
  local s = u[0]
  local s1 = u1 and u1[0]
  local s2 = u2 and u2[0]
  local s3 = u3 and u3[0]
  local s4 = u4 and u4[0]

  if s == symbol_table.stat then
    if s1 == symbol_table["goto"] then
      local result, message = ref_label(u2)
      if not result then
        error(error_message(message, source, u2.i, source_file))
      end
    end
  end
end

local next_path = {}
for i = #terminal_nodes, 1, -1 do
  local u = terminal_nodes[i]

  u.next_path = next_path
  local path = u.path
  if path then
    next_path = path
  end
end

local prev_path = {}
for i = 1, #terminal_nodes do
  local u = terminal_nodes[i]
  local s = u[0]

  u.prev_path = prev_path
  local path = u.path
  if path then
    prev_path = path
  else
    u.path = common_path(prev_path, u.next_path)
  end

  if s == symbol_table["false"] or s == symbol_table["true"] then
    u.highlight = { "constant", "boolean" }
  elseif s == symbol_table["nil"] then
    u.highlight = { "constant" }
  elseif s == symbol_table["and"] or s == symbol_table["not"] or s == symbol_table["or"] or s == symbol_table[".."] then
    u.highlight = { "statement", "operator" }
  elseif s == symbol_table["function"] or s == symbol_table["{"] or s == symbol_table["}"] then
    u.highlight = { "type", "structure" }
  elseif s == symbol_table["end"] then
    if u.funcbody_end then
      u.highlight = { "type", "structure" }
    else
      u.highlight = { "statement" }
    end
  elseif s == symbol_table.Name then
    u.highlight = { "identifier" }
  elseif s == symbol_table.LiteralString then
    u.highlight = { "constant", "string" }
  elseif s == symbol_table.IntegerConstant then
    u.highlight = { "constant", "number", "integer" }
  elseif s == symbol_table.FloatConstant then
    u.highlight = { "constant", "number", "float" }
  else
    local value = symbol_value(u)
    if value:find("^[a-z]") then
      u.highlight = { "statement" }
    elseif value:find("^[+%-*/%%^#&~|<>=]") then
      u.highlight = { "statement", "operator" }
    end
  end
end

local line_number = source:find("\n$") and 0 or 1
for _ in source:gmatch("\n") do
  line_number = line_number + 1
end

local number_html = { "div"; class = "number" }
for i = 1, line_number do
  number_html[#number_html + 1] = { "span";
    id = "L" .. i;
    i .. "\n";
  }
end

local source_left = math.ceil(math.log(line_number, 10)) * 0.5 + 1

local source_html = { "div"; class = "source" }
for i = 1, #terminal_nodes do
  local u = terminal_nodes[i]
  local s = u[0]
  local p = u.p
  local i = u.i
  local j = u.j
  local path = u.path

  if p < i then
    local class = {}
    local path = common_path(path, u.prev_path)
    for i = 1, #path do
      class[#class + 1] = "S" .. path[i]
    end
    class[#class + 1] = "highlight-comment"
    source_html[#source_html + 1] = { "span";
      class = class;
      source:sub(p, i - 1)
    }
  end

  if s ~= 1 then
    local class = {}
    for i = 1, #path do
      class[#class + 1] = "S" .. path[i]
    end
    local id = u.id
    if id then
      id = "S" .. id
      class[#class + 1] = id
      class[#class + 1] = "S"
    end
    local highlight = u.highlight
    if highlight then
      for i = 1, #highlight do
        class[#class + 1] = "highlight-" .. highlight[i]
      end
    end
    source_html[#source_html + 1] = { "span";
      id = id;
      class = class;
      source:sub(i, j)
    }
  end
end

local tree_width = 640
local tree_height = 480
local node_width = 160
local node_height = 32

tree_layout(root, node_height, node_width, "y", "x")

local defs = {}
local defs_html = { "defs" }
local edges_html = { "g"; class = "edges" }
local nodes_html = { "g"; class = "nodes" }

for i = 1, #discover_nodes do
  local u = discover_nodes[i]
  local s = u[0]
  local ux = u.x
  local uy = u.y

  if not defs[s] then
    local name = symbol_names[s]
    local h = 24
    local w = #name * 8 + h
    local r = h * 0.5
    local class = {}
    defs[s] = true
    defs_html[#defs_html + 1] = { "g";
      id = "D" .. s;
      { "rect";
        x = -w * 0.5;
        y = -r;
        width = w;
        height = h;
        rx = r;
        ry = r;
      };
      { "text"; name };
    }
  end

  nodes_html[#nodes_html + 1] = { "use";
    id = "T" .. u.id;
    class = "T";
    transform = ("translate(%.17g,%.17g)"):format(ux, uy);
    ["xlink:href"] = "#D" .. s;
  }

  for i = 1, #u do
    local v = u[i]
    local vx = v.x
    local vy = v.y
    local mx = (ux + vx) * 0.5
    edges_html[#edges_html + 1] = { "path";
      d = ("M%.17g,%.17gC%.17g,%.17g,%.17g,%.17g,%.17g,%.17g"):format(ux, uy, mx, uy, mx, vy, vx, vy);
    };
  end
end

local name_html = { "tbody" }
local label_html = { "tbody" }

local scopes = root.scopes
for i = 1, #scopes do
  local scope = scopes[i]
  local names = scope.names
  for j = 1, #names do
    local name = names[j]
    name_html[#name_html + 1] = { "tr";
      { "td"; i };
      { "td"; j };
      { "td"; name.value };
      make_refs_html({ "td" }, name.defs);
      make_refs_html({ "td" }, name.refs);
    }
  end
  local labels = scope.labels
  for j = 1, #labels do
    local label = labels[j]
    label_html[#label_html + 1] = { "tr";
      { "td"; i };
      { "td"; j };
      { "td"; label.value };
      make_refs_html({ "td" }, label.defs);
      make_refs_html({ "td" }, label.refs);
    }
  end
end

local constant_html = { "tbody" }

local protos = root.protos
for i = 1, #protos do
  local proto = protos[i]
  local constants = proto.constants
  for j = 1, #constants do
    local constant = constants[j]
    local type = constant.type
    local value = constant.value
    if type == "string" then
      value = dumper.encode_string(value)
    end
    constant_html[#constant_html + 1] = { "tr";
      { "td"; i };
      { "td"; j };
      { "td"; type };
      { "td"; value };
      make_refs_html({ "td" }, constant.refs)
    }
  end
end

local style = ([[
.source {
  left: %.17grem;
}
.tree {
  width: %.17grem;
}
]]):format(source_left, tree_width / 16)

local script = ([[
/*jslint this,white*/
"use strict";
(function (root) {
  root.dromozoa = {
    parser: {
      setting: {
        node_width: %.17g,
        node_height: %.17g
      }
    }
  };
}(this.self));
]]):format(node_width, node_height)

local out = assert(io.open(html_file, "w"))
out:write("<!DOCTYPE html>")
write_html(out, { "html"; lang = "ja";
  { "head";
    { "meta"; charset = "UTF-8" };
    { "meta"; name = "viewport"; content = "width=device-width, initial-scale=1, shrink-to-fit=no" };
    { "title"; source_file };
    { "link"; rel = "stylesheet"; href = "https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css" };
    { "link"; rel = "stylesheet"; href = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" };
    { "style"; style };
    { "link"; rel = "stylesheet"; href = "dromozoa-parser-luac.css" };
  };
  { "body";
    number_html;
    source_html;

    { "div"; class = "panel panel-svg tree";
      { "div"; class = "head";
        { "span"; "Tree" };
      };
      { "div"; class = "body";
        { "svg"; class = "body"; width = tree_width; height = tree_height;
          defs_html;
          { "g"; class = "viewport";
            { "rect"; width = tree_width; height = tree_height };
            { "g"; class = "view";
              { "g"; class = "model";
                edges_html;
                nodes_html;
              };
            };
          };
        };
      };
    };

    { "div"; class = "panel panel-table names";
      { "div"; class = "head";
        { "span"; "Names" };
      };
      { "div"; class = "body";
        { "table";
          { "thead";
            { "tr";
              { "th"; colspan = 2; "#" };
              { "th"; "name" };
              { "th"; "def" };
              { "th"; "ref" };
            };
          };
          name_html;
        };
      };
    };

    { "div"; class = "panel panel-table labels";
      { "div"; class = "head";
        { "span"; "Labels" };
      };
      { "div"; class = "body";
        { "table";
          { "thead";
            { "tr";
              { "th"; colspan = 2; "#" };
              { "th"; "label" };
              { "th"; "def" };
              { "th"; "ref" };
            };
          };
          label_html;
        };
      };
    };

    { "div"; class = "panel panel-table constants";
      { "div"; class = "head";
        { "span"; "Constants" };
      };
      { "div"; class = "body";
        { "table";
          { "thead";
            { "tr";
              { "th"; colspan = 2; "#" };
              { "th"; "type" };
              { "th"; "value" };
              { "th"; "ref" };
            };
          };
          constant_html;
        };
      };
    };

    { "div"; class = "menu";
      { "div"; class = "head";
        { "span"; class = "fa fa-bars" };
      };
      { "div"; class = "body";
        { "div"; class = "toggle"; ["data-toggle"] = ".tree"; "Tree"; };
        { "div"; class = "toggle"; ["data-toggle"] = ".names"; "Names"; };
        { "div"; class = "toggle"; ["data-toggle"] = ".labels"; "Labels"; };
        { "div"; class = "toggle"; ["data-toggle"] = ".constants"; "Constants"; };
      };
    };

    { "script"; src = "https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" };
    { "script"; src = "https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" };
    { "script"; src = "https://cdnjs.cloudflare.com/ajax/libs/d3/4.10.0/d3.min.js" };
    { "script"; script };
    { "script"; src = "dromozoa-parser-luac.js" };
  };
})
out:write("\n")
out:close()
