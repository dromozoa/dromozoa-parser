#! /usr/bin/env lua

-- Copyright (C) 2017 Tomoyuki Fujimori <moyu@dromozoa.com>
--
-- This file is part of dromozoa-parser.
--
-- dromozoa-parser is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- dromozoa-parser is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with dromozoa-parser.  If not, see <http://www.gnu.org/licenses/>.

local data_dumper = require "dromozoa.commons.dumper"
local write_html = require "dromozoa.parser.write_html"
local symbol_value = require "dromozoa.parser.value"
local tree_layout = require "dromozoa.parser.tree_layout"
local lua53_lexer = require "dromozoa.parser.lexers.lua53_lexer"
local lua53_parser = require "dromozoa.parser.parsers.lua53_parser"

local function ref_constant(proto, id, type, value)
  local constants = proto.constants
  local n = #constants
  for i = n, 1, -1 do
    local constant = constants[i]
    if constant.type == type and constant.value == value then
      local refs = constant.refs
      refs[#refs + 1] = id
      return i
    end
  end
  n = n + 1
  constants[n] = {
    type = type;
    value = value;
    refs = { id };
  }
  return n
end

local function copy_path(source, result)
  if result == nil then
    result = {}
  end
  for i = 1, #source do
    result[i] = source[i]
  end
  return result
end

local function common_path(path1, path2, result)
  if result == nil then
    result = {}
  end
  for i = 1, #path1 do
    local v = path1[i]
    if v == path2[i] then
      result[i] = v
    else
      break
    end
  end
  return result
end

local source_file, html_file = ...
local source

if source_file then
  local handle = assert(io.open(source_file))
  source = handle:read("*a")
  handle:close()
else
  source = io.read("*a")
end

local lexer = lua53_lexer()
local parser = lua53_parser()

local symbol_names = parser.symbol_names
local symbol_table = parser.symbol_table
local max_terminal_symbol = parser.max_terminal_symbol
local terminal_nodes = assert(lexer(source, file))
local root = assert(parser(terminal_nodes, source, file))

root.path = {}

local id = 0
local nodes = {}

local protos = {}
local proto

local env = {
  names = {};
  labels = {};
}
local scope = env

local stack1 = { root }
local stack2 = {}
while true do
  local n1 = #stack1
  local u = stack1[n1]
  if not u then
    break
  end
  local n2 = #stack2
  if u == stack2[n2] then
    stack1[n1] = nil
    stack2[n2] = nil
    nodes[#nodes + 1] = u

    local u1, u2, u3, u4 = u[1], u[2], u[3], u[4], u[5]
    local s = u[0]
    local s1 = u1 and u1[0]
    local s2 = u2 and u2[0]
    local s3 = u3 and u3[0]
    local s4 = u4 and u4[0]

    if s == symbol_table.IntegerConstant then
      u.out = ref_constant(proto, u.id, "integer", tonumber(symbol_value(u)))
    elseif s == symbol_table.FloatConstant then
      u.out = ref_constant(proto, u.id, "float", tonumber(symbol_value(u)))
    elseif s == symbol_table.StringLiteral then
      u.out = ref_constant(proto, u.id, "string", symbol_value(u))
    end

    if u.proto then
      proto = proto.parent
    end
    if u.scope then
      scope = scope.parent
    end
  else
    id = id + 1
    u.id = id

    local path = copy_path(u.path)
    path[#path + 1] = id

    if u.proto then
      proto = {
        parent = proto;
        constants = {};
        locals = {};
        upvalues = {};
      }
      protos[#protos + 1] = proto
      u.proto = proto
    end
    if u.scope then
      scope = {
        node_id = id;
        parent = scope;
        names = {};
        labels = {};
      }
      u.scope = scope
    end

    local n = #u
    for i = n, 1, -1 do
      local v = u[i]
      v.parent = u
      v.path = path
      stack1[#stack1 + 1] = v
    end
    stack2[n2 + 1] = u
  end
end

for i = 1, #protos do
  print(data_dumper.encode(protos[i].constants, { pretty = true, stable = true }))
end

local next_path = {}
for i = #terminal_nodes, 1, -1 do
  local u = terminal_nodes[i]

  u.next_path = next_path
  local path = u.path
  if path then
    next_path = path
  end
end

local prev_path = {}
for i = 1, #terminal_nodes do
  local u = terminal_nodes[i]
  local s = u[0]

  u.prev_path = prev_path
  local path = u.path
  if path then
    prev_path = path
  else
    u.path = common_path(prev_path, u.next_path)
  end

  if s == symbol_table["false"] or s == symbol_table["true"] then
    u.highlight = { "constant", "boolean" }
  elseif s == symbol_table["nil"] then
    u.highlight = { "constant" }
  elseif s == symbol_table["and"] or s == symbol_table["not"] or s == symbol_table["or"] or s == symbol_table[".."] then
    u.highlight = { "statement", "operator" }
  elseif s == symbol_table["function"] or s == symbol_table["{"] or s == symbol_table["}"] then
    u.highlight = { "type", "structure" }
  elseif s == symbol_table["end"] then
    if u.funcbody_end then
      u.highlight = { "type", "structure" }
    else
      u.highlight = { "statement" }
    end
  elseif s == symbol_table.Name then
    u.highlight = { "identifier" }
  elseif s == symbol_table.LiteralString then
    u.highlight = { "constant", "string" }
  elseif s == symbol_table.IntegerConstant then
    u.highlight = { "constant", "number", "integer" }
  elseif s == symbol_table.FloatConstant then
    u.highlight = { "constant", "number", "float" }
  else
    local value = symbol_value(u)
    if value:find("^[a-z]") then
      u.highlight = { "statement" }
    elseif value:find("^[+%-*/%%^#&~|<>=]") then
      u.highlight = { "statement", "operator" }
    end
  end
end

local line_number = source:find("\n$") and 0 or 1
for _ in source:gmatch("\n") do
  line_number = line_number + 1
end

local number_html = { "div"; class = "number" }
for i = 1, line_number do
  number_html[#number_html + 1] = { "span";
    id = "L" .. i;
    i .. "\n";
  }
end

local source_left = math.ceil(math.log(line_number, 10)) * 0.5 + 1

local source_html = { "div"; class = "source" }
for i = 1, #terminal_nodes do
  local u = terminal_nodes[i]
  local s = u[0]
  local p = u.p
  local i = u.i
  local j = u.j
  local path = u.path

  if p < i then
    local class = {}
    local path = common_path(path, u.prev_path)
    for i = 1, #path do
      class[#class + 1] = "S" .. path[i]
    end
    class[#class + 1] = "highlight-comment"
    source_html[#source_html + 1] = { "span";
      class = class;
      source:sub(p, i - 1)
    }
  end

  if s ~= 1 then
    local class = {}
    for i = 1, #path do
      class[#class + 1] = "S" .. path[i]
    end
    local id = u.id
    if id then
      id = "S" .. id
      class[#class + 1] = id
      class[#class + 1] = "S"
    end
    local highlight = u.highlight
    if highlight then
      for i = 1, #highlight do
        class[#class + 1] = "highlight-" .. highlight[i]
      end
    end
    source_html[#source_html + 1] = { "span";
      id = id;
      class = class;
      source:sub(i, j)
    }
  end
end

local tree_width = 640
local tree_height = 480
local node_width = 160
local node_height = 32

tree_layout(root, node_height, node_width, "y", "x")

local defs = {}
local defs_html = { "defs" }
local edges_html = { "g"; class = "edges" }
local nodes_html = { "g"; class = "nodes" }

for i = 1, #nodes do
  local u = nodes[i]
  local s = u[0]
  local ux = u.x
  local uy = u.y

  if not defs[s] then
    local name = symbol_names[s]
    local h = 24
    local w = #name * 8 + h
    local r = h * 0.5
    local class = {}
    defs[s] = true
    defs_html[#defs_html + 1] = { "g";
      id = "D" .. s;
      { "rect";
        x = -w * 0.5;
        y = -r;
        width = w;
        height = h;
        rx = r;
        ry = r;
      };
      { "text"; name };
    }
  end

  nodes_html[#nodes_html + 1] = { "use";
    id = "T" .. u.id;
    class = "T";
    transform = ("translate(%.17g,%.17g)"):format(ux, uy);
    ["xlink:href"] = "#D" .. s;
  }

  for i = 1, #u do
    local v = u[i]
    local vx = v.x
    local vy = v.y
    local mx = (ux + vx) * 0.5
    edges_html[#edges_html + 1] = { "path";
      d = ("M%.17g,%.17gC%.17g,%.17g,%.17g,%.17g,%.17g,%.17g"):format(ux, uy, mx, uy, mx, vy, vx, vy);
    };
  end
end

local tree_html = { "div"; class = "tree";
  { "svg"; width = tree_width; height = tree_height;
    defs_html;
    { "g"; class = "viewport";
      { "rect"; width = tree_width; height = tree_height };
      { "g"; class = "view";
        { "g"; class = "model";
          edges_html;
          nodes_html;
        };
      };
    };
  };
}

local style = ([[
.source {
  left: %.17grem;
}
]]):format(source_left)

local script = ([[
/*jslint this,white*/
"use strict";
(function (root) {
  root.dromozoa = {
    parser: {
      setting: {
        tree_width: %.17g,
        tree_height: %.17g,
        node_width: %.17g,
        node_height: %.17g
      }
    }
  };
}(this.self));
]]):format(tree_width, tree_height, node_width, node_height)

local out = assert(io.open(html_file, "w"))
out:write("<!DOCTYPE html>")
write_html(out, { "html"; lang = "ja";
  { "head";
    { "meta"; charset = "UTF-8" };
    { "meta"; name = "viewport"; content = "width=device-width, initial-scale=1, shrink-to-fit=no" };
    { "title"; source_file };
    { "link"; rel = "stylesheet"; href = "https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-beta/css/bootstrap.min.css" };
    { "link"; rel = "stylesheet"; href = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" };
    { "style"; style };
    { "link"; rel = "stylesheet"; href = "dromozoa-parser-luac.css" };
  };
  { "body";
    { "nav"; class = "navbar navbar-expand-sm navbar-light bg-light fixed-top";
      { "div"; class = "container";
        { "button"; class = "navbar-toggler"; type = "button"; ["data-target"] = "#navbar"; ["data-toggle"] = "collapse";
          { "span"; class = "navbar-toggler-icon" };
        };
        { "div"; id = "navbar"; class = "navbar-collapse collapse";
          { "div"; class = "navbar-nav";
            { "a"; class = "nav-item nav-link"; href = "#"; "Tree" };
            { "a"; class = "nav-item nav-link"; href = "#"; "Proto" };
            { "a"; class = "nav-item nav-link"; href = "#"; "Scope" };
          };
        };
      };
    };
    number_html;
    source_html;
    tree_html;
    { "script"; src = "https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" };
    { "script"; src = "https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.5/umd/popper.min.js" };
    { "script"; src = "https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-beta/js/bootstrap.min.js" };
    { "script"; src = "https://cdnjs.cloudflare.com/ajax/libs/d3/4.10.0/d3.min.js" };
    { "script"; script };
    { "script"; src = "dromozoa-parser-luac.js" };
  };
})
out:write("\n")
out:close()
